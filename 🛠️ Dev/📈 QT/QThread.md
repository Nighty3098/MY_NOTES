---
tags:
  - qt
---

Потоки в операционной системе - это очень простая вещь. Напишите функцию, возможно, обвяжите ее некоторыми данными и поместите ее во вновь созданный поток. При необходимости используйте мьютекс или другой метод для безопасного взаимодействия с потоком. Будь то потоки Win32, POSIX или другие, все они в основном работают одинаково и вполне защищены от дурака.
[[Многоязычное приложение. C++ QT]]
Те, кто открыл для себя радости фреймворка Qt, могут предположить, что потоки в Qt работают точно так же, и они будут правы. Однако существует несколько различных способов использования потоков в Qt, и может быть неочевидно, какой подход выбрать. В статье "Технологии многопоточности в Qt" сравниваются различные подходы.

В этой части статьи демонстрируется один из этих методов: QThread + рабочий QObject. Этот метод предназначен для случаев использования, которые включают событийно-ориентированное программирование и сигналы + слоты между потоками.

Использование с классом Worker
Главное, о чем следует помнить при использовании QThread в этом примере, - это то, что это не поток. Это обертка вокруг объекта потока. Эта обертка предоставляет сигналы, слоты и методы, чтобы легко использовать объект потока в проекте Qt. Чтобы использовать ее, подготовьте подкласс QObject со всей необходимой вам функциональностью в нем. Затем создайте новый экземпляр QThread, поместите в него QObject с помощью moveToThread(QThread*) экземпляра QObject и вызовите start() на экземпляре QThread. Вот и все. Вы устанавливаете соответствующие сигнальные/слотовые соединения, чтобы он правильно выходил и все такое, и это все.

Объявление класса Worker
Для базового примера посмотрите объявление класса Worker:

```cpp
class Worker : public QObject {
    Q_OBJECT
public:
    Worker();
    ~Worker();
публичные слоты:
    void process();
сигналы:
    void finished();
    void error(QString err);
private:
    // добавьте сюда свои переменные
};
```

Мы добавляем по крайней мере один публичный слот, который будет использоваться для запуска экземпляра, чтобы он начал обрабатывать данные после запуска потока. Теперь давайте посмотрим, как выглядит реализация этого базового класса.

```cpp
Worker::Worker() { // Конструктор
    // здесь можно скопировать данные из аргументов конструктора во внутренние переменные.
}

Worker::~Worker() { // Деструктор
    // освобождение ресурсов
}

void Worker::process() { // Обработка. Начинаем обработку данных.
    // выделение ресурсов с помощью new here
    qDebug("Hello World!");
    emit finished();
}
```

Хотя этот класс Worker не делает ничего особенного, он, тем не менее, содержит все необходимые элементы. Он начинает обработку, когда вызывается его главная функция, в данном случае process(), и по окончании работы издает сигнал finished(), который затем будет использован для выключения экземпляра QThread, в котором он находится.

Кстати, здесь необходимо отметить одну очень важную вещь: вы НИКОГДА не должны выделять объекты кучи (используя new) в конструкторе класса QObject, поскольку это выделение происходит в главном потоке, а не в новом экземпляре QThread, что означает, что вновь созданный объект будет принадлежать главному потоку, а не экземпляру QThread. Это приведет к тому, что ваш код не будет работать. Вместо этого выделяйте такие ресурсы в слоте главной функции, например process(), поскольку при ее вызове объект будет находиться в новом экземпляре потока и, следовательно, будет владеть ресурсом.

Создание нового экземпляра Worker
Теперь давайте посмотрим, как использовать эту новую конструкцию, создав новый экземпляр Worker и поместив его на экземпляр QThread:

```cpp
QThread* thread = new QThread();
Worker* worker = new Worker();
worker->moveToThread(thread);
connect( worker, &Worker::error, this, &MyClass::errorString);
connect( thread, &QThread::started, worker, &Worker::process);
connect( worker, &Worker::finished, thread, &QThread::quit);
connect( worker, &Worker::finished, worker, &Worker::deleteLater);
connect( thread, &QThread::finished, thread, &QThread::deleteLater);
thread->start();
```

Серия connect() здесь является самой важной частью. Первая строка connect() подключает сигнал сообщения об ошибке от рабочего к функции обработки ошибок в главном потоке. Вторая соединяет сигнал потока started() со слотом processing() в рабочем, вызывая его запуск.

Затем очистка: когда экземпляр рабочего выдает finished(), как мы делали в примере, он сигнализирует потоку о выходе, то есть о завершении работы. Затем мы помечаем рабочий экземпляр с помощью того же сигнала finished() для удаления. Наконец, чтобы предотвратить неприятные сбои из-за того, что поток еще не полностью закрылся при удалении, мы подключаем finished() потока (не рабочего!) к его собственному слоту deleteLater(). Это приведет к тому, что поток будет удален только после того, как он полностью завершится.
