---
tags:
  - CPP
  - MemUsage
  - Optimization
---
## Библиотеки для управления памятью в C++

В C++ управление памятью можно осуществлять как с помощью стандартных операторов `new` и `delete`, так и с использованием различных библиотек и инструментов, которые упрощают и делают более безопасным процесс работы с динамической памятью. Ниже приведены основные библиотеки и подходы для управления памятью в C++.

### 1. Стандартные операторы управления памятью

- **`new` и `delete`**: Эти операторы используются для выделения и освобождения памяти в C++. Они обеспечивают вызов конструктора и деструктора объектов.

```cpp
int* ptr = new int; // Выделение памяти для одного целого числа
delete ptr;        // Освобождение памяти
```

- **`new[]` и `delete[]`**: Эти операторы используются для работы с массивами.

```cpp
int* arr = new int[10]; // Выделение массива из 10 целых чисел
delete[] arr;           // Освобождение памяти массива
```

### 2. Умные указатели

Современный C++ предлагает умные указатели, которые автоматически управляют памятью, что помогает избежать утечек памяти.

- **`std::unique_ptr`**: Указатель, который владеет объектом и автоматически освобождает его при выходе из области видимости.

```cpp
#include <memory>

std::unique_ptr<int> ptr(new int(42)); // Автоматически освобождает память при выходе из области видимости
```

- **`std::shared_ptr`**: Указатель, который позволяет нескольким указателям совместно владеть объектом. Память освобождается, когда последний `shared_ptr`, указывающий на объект, уничтожается.

```cpp
#include <memory>

std::shared_ptr<int> ptr1(new int(42));
std::shared_ptr<int> ptr2 = ptr1; // Теперь оба указателя владеют одним объектом
```

- **`std::weak_ptr`**: Указатель, который не владеет объектом, но может получить доступ к нему через `shared_ptr`. Используется для предотвращения циклических ссылок.

```cpp
#include <memory>

std::shared_ptr<int> sharedPtr(new int(42));
std::weak_ptr<int> weakPtr = sharedPtr; // Не увеличивает счетчик ссылок
```

### 3. Библиотеки для управления памятью

Существуют также сторонние библиотеки, которые могут помочь в управлении памятью:

- **Boost**: Библиотека Boost предоставляет множество инструментов для работы с динамической памятью, включая умные указатели и контейнеры, которые управляют своей памятью автоматически.

```cpp
#include <boost/shared_ptr.hpp>

boost::shared_ptr<int> ptr(new int(42)); // Использование Boost для управления памятью
```

- **Google TCMalloc**: Это библиотека для управления памятью, которая оптимизирована для многопоточных приложений. Она может быть использована вместо стандартного менеджера памяти C++.

- **jemalloc**: Это еще одна библиотека для управления памятью, которая предлагает улучшенные характеристики производительности по сравнению со стандартными механизмами выделения памяти.

### 4. Стандартные функции C

Также можно использовать функции стандартной библиотеки C (`malloc`, `calloc`, `realloc`, `free`) для управления динамической памятью. Однако это менее безопасно по сравнению с использованием операторов C++ и умных указателей.

```cpp
#include <cstdlib>

int* arr = (int*)malloc(10 * sizeof(int)); // Выделение памяти
free(arr); // Освобождение памяти
```


[1] https://prog-cpp.ru/cpp-newdelete/
[2] https://learn.microsoft.com/ru-ru/windows/win32/memory/standard-c-library-functions
[3] https://nsu-programming.github.io/textbook/cpp/dynamic-memory.html
[4] https://alexgyver.ru/lessons/dynamic-memory/